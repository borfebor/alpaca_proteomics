{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#alpaca_proteomics-a-python-based-proteomics-pipeline-for-absolute-protein-quantification","title":"\ud83d\udcca alpaca_proteomics: A Python-based Proteomics Pipeline for absolute protein quantification","text":"<p><code>alpaca_proteomics</code> is a Python-based pipeline designed for Absolute Protein Quantification in proteomics research. It streamlines the analysis of mass spectrometry data, enabling accurate determination of protein abundances in complex biological samples. By supporting various proteomics data formats and employing robust statistical methods, it enhances the reliability of quantitative analyses.</p>"},{"location":"#key-features","title":"\ud83e\uddd1\u200d\ud83d\udd2c Key Features","text":""},{"location":"#1-data-import-and-pre-processing","title":"1. Data Import and Pre-processing","text":"<p>The pipeline facilitates the import and pre-processing of raw experimental data, transforming it into a clean, standardized format suitable for downstream analysis.</p>"},{"location":"#2-quantification","title":"2. Quantification","text":"<p>It offers functionalities for absolute protein quantification, allowing researchers to determine protein abundances accurately.</p>"},{"location":"#3-graphical-user-interface-gui","title":"3. Graphical User Interface (GUI)","text":"<p>For user-friendly interaction, a GUI is available, providing an intuitive interface for data analysis tasks.</p>"},{"location":"#installation","title":"\ud83d\udee0\ufe0f Installation","text":"<p>To get started, you can install the library via pip:</p> <pre><code>pip install alpaca-proteomics\n</code></pre>"},{"location":"Tutorial/","title":"Tutorial","text":""},{"location":"Tutorial/#data-import-and-formatting","title":"Data import and formatting","text":"<p>Alpaca works with unprocessed proteomics datasets from MaxQuant. The package takes the file <code>proteinGroups.txt</code>, which can be found in the combined folder of MaxQuant output. This dataset is from the exoproteome data published in Ferrero-Bordera et al. 2024. Microbiology Spectrum.</p> <pre><code>from alpaca_proteomics import alpaca\n\nfile = 'proteinGroups.txt'\n\n# Data importation\ndf, id_col, it = alpaca.eats('proteinGroups.txt')\n</code></pre> <pre><code>The column Protein IDs was detected to contain your ProteinGroups IDs.\nThe following intensity methods were detected in the data: Intensity, iBAQ, LFQ\n</code></pre> <p>The function returned:</p> <ul> <li>df is the imported data as a pandas dataframe</li> <li>id_col corresponds to the column which was detected to contain the Protein IDs</li> <li>it is a dictionary which groups the columns containing intensity data within each intensity method (e.g. LFQ)</li> </ul> <p>In our example, the data contained 3 intensity methods (Intensity, iBAQ, LFQ)</p>"},{"location":"Tutorial/#assistance-on-the-analysis-optional","title":"Assistance on the analysis (Optional)","text":"<pre><code>standards_file = 'UPS2.xlsx' # Path to the anchor proteins file\nst_proteins = alpaca.eats(standards_file) # Importation of the anchor proteins file (more details on these are listed below)\nspiked_samples = ['Before_Induction_01', 'Control_01', 'Diamide_01'] # Samples in which anchor proteins were added\nvalues_per_sample = 1/4 # Valid values per condition\n\nsuggested = alpaca.Consultant(df,\n                         st_proteins,\n                         it, \n                         added_samples=spiked_samples,\n                         values_per_sample=values_per_sample)\n</code></pre> <pre><code>Based on your data, Median-normalized iBAQ is recommended for the quantification.\n</code></pre> <p>The function returns a suggested analysis method and a dataframe with the calculated scores for each intensity method with different normalization approaches. These data is visualized below.</p> <pre><code>import seaborn as sns\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\nplt.figure(figsize=(5,5))\nsns.set(font_scale=1.5)\nsns.heatmap(suggested.pivot(index='Normalization', columns='Intensity method', values='score'),\n           annot=True, cmap='viridis', lw=1, cbar_kws={'label': 'Fitting (R$^2$)'})\n</code></pre> <pre><code>&lt;Axes: xlabel='Intensity method', ylabel='Normalization'&gt;\n</code></pre> <p></p>"},{"location":"Tutorial/#data-pre-processing","title":"Data pre-processing","text":"<p>Based on the suggestions from the function alpaca.Consultant, the analysis can continue with the most suitable parameters</p> <pre><code># Data pre-processing\n\nvalues_per_sample = 1/4\n\nclean_df = alpaca.spits(df, \n                        lfq_method='iBAQ',\n                        formatting=True, \n                        valid_values=values_per_sample,\n                        normalization='Median',\n                        info_cols=['Accession', 'Gene names'])\nclean_df.head(5)\n</code></pre> <pre><code>3 experimental conditions were identified in the data: Before_Induction, Control, Diamide\nItems marked on Only identified by site, Reverse, Potential contaminant have been removed from the dataset.\nDataset formated for further analysis and visualisation.\n</code></pre> Accession Protein Sample iBAQ Condition Replicate 3 C0SP82 YoaE iBAQ Before_Induction_01 2.083660 Before_Induction 01 4 C0SP93 AccD iBAQ Before_Induction_01 2.312376 Before_Induction 01 5 C0SP94 YhfQ iBAQ Before_Induction_01 -2.030633 Before_Induction 01 6 C0SPA7 YukB iBAQ Before_Induction_01 -8.627621 Before_Induction 01 7 C0SPB0 YtcI iBAQ Before_Induction_01 0.498673 Before_Induction 01"},{"location":"Tutorial/#anchor-protein-quantification","title":"Anchor protein quantification","text":"<p>Absolute quantification using Alpaca is optimised for label-free methods, relying on the addition of a set of anchor proteins at a known amount. </p> <p>Table 1. Format for the file describing the stock solution of anchor proteins.</p> Accession MW (kDa) Amount (fmol) P02768 10.1 50 Q9Y6K9 65.8 100 P05067 32.5 25 O75475 48.2 75 Q00653 20.9 30 <pre><code># Import the file containing the information about the quantification standards proteins\n\nstandards_file = 'UPS2.xlsx'\nst_proteins = alpaca.eats(standards_file)\n\n# If applicable, define which samples/replicates contain standards proteins\n\nspiked_samples = ['iBAQ Before_Induction_01', 'iBAQ Control_01', 'iBAQ Diamide_01']\n\n# Quantify the fmol present in the measured samples\n\nquant_df, st_proteins, coef, inter, r2 = alpaca.census(clean_df, st_proteins, lfq_col='iBAQ',\n                                                      filter_col = 'Sample', # Defines which column to filter for the spiked samples\n                                                      added_samples = spiked_samples) # Adding which samples contain the standars\n</code></pre> <p></p> <p><code>alpaca.census()</code> adds a column to the processed data with the calculated mol amounts present in the measured samples.</p>"},{"location":"Tutorial/#experimental-details","title":"Experimental details","text":"<pre><code>sample_prep = pd.read_csv('params.csv', sep=',')\nsample_prep.sample()\n</code></pre> <p>Experimental details (in our example <code>params.txt</code>) can be added as txt, csv or xlsx formats. This file can include the columns described in the following table:</p> <p>Table 2. Experimental parameters table. This example covers all possible columns. Nonetheless, not all columns are necessary. For example, Enrichment columns (EnrichmentMode, StdDilution, StdVolume) are only used if any enrichment step was performed. More information about this is described in the Enrichment section.</p> Condition SampleVolume ProteinConcentration AmountMS CellsPerML TotalCultureVolume ProteinSRM fmolSRM Enrichment EnrichmentMode StdDilution StdVolume Cond1_t0 2.31 2.99 9.67 4.54 7.54 TNAMLN 4.44 False 3.96 1.22 Cond2_t1 2.50 0.20 4.10 5.13 2.62 AJFVYC 4.85 True Concentration 2.43 1.51 Cond3_t2 7.38 6.56 2.77 3.66 3.80 BYEKSC 9.71 True Enrichment 5.71 8.53"},{"location":"Tutorial/#proteome-fraction-enrichment-optional","title":"Proteome fraction enrichment (Optional)","text":"<p>In case the study focuses in a fraction of the proteome (e.g., membrane proteome or exoproteome), it is likely that during the sample preparation an enrichment step was performed. This module allows to translate the enrichment step to the data based on how the samples were prepared. </p> <p><code>Enrichment factors</code> are calculated based on the fmol quantified in the enriched sample to the raw or non-enriched sample:</p> <p>$$ ER = \\frac{fmol_{enriched}}{fmol_{non-enriched}} $$</p> <p>For that purpose, there are 2 strategies that are currently covered under in Alpaca:</p> <p>1. The quantification of specific proteins of the analysed fraction before and after the enrichment step using Targeted MS (SRM). </p> <p>This strategy was described on Antelo-Varela et al. 2019 and relies on using external protocols (e.g., Skyline) to quantify the enrichment step. Enrichment factors can be added to the parameters table under the column <code>Enrichment_Factor</code>. Additionally, the SRM quantified amount for a given protein can be added on the columns <code>ProteinSRM</code> (Accession of the quantified protein) and <code>fmolSRM</code> (Quantified fmol in the analysed proteome fraction).</p> <p>2. The addition of whole proteins at known concentration before performing the enrichment step.</p> <p>This approach was described on Ferrero-Bordera et al. 2024 and requires a protein mixture at known concentration added before the enrichment step. Used standards have to be formatted as specified in the table below:</p> <p>Table 3. Enrichment standards</p> Accession MW (kDa) StdConcentration (\u00b5g/\u00b5l) P02768 10.1 2.5 Q9Y6K9 65.8 0.8 P05067 32.5 1.2 O75475 48.2 3.0 Q00653 20.9 2.0 <pre><code># Enrichment Standard importation\n\nenrichment_std = pd.read_excel('enrichment_std.xlsx')\nenrichment_std.sample(3)\n</code></pre> Protein Accession Chain length MW (kDa) StdConcentration 4 Lysozyme P00698 129 aa 14.3 17.780320 2 Alcohol Dehydrogenase P00330 348 aa 36.8 45.756347 3 Soybean Trypsin Inhibitor P01071 181 aa 20.0 24.867580 <pre><code>enrichment_std, sample_prep_updated = alpaca.gathers(clean_df, enrichment_std, sample_prep)\n</code></pre> <pre><code>Enrichment factor for condition Before_Induction: 17.97\nEnrichment factor for condition Control: 34.65\n</code></pre>"},{"location":"Tutorial/#data-integration","title":"Data integration","text":"<p>This module connects the protein amounts quantified in the sample and the sample preparation. Thus, allowing to calculate protein amounts to the original state (e.g. bacterial culture, raw culture supernatant). This step yields absolute quantification data (e.g., molecules per cell, fmol / \u00b5mol of protein extract)</p> <pre><code>results = alpaca.wool(quant_df, sample_prep_updated)\n\nresults.sample(3)\n</code></pre> Accession Protein Sample iBAQ Condition Replicate fmol Molecules fmolSample MoleculesPerCell 14063 P29252 FolK iBAQ Diamide_03 -1.290911 Diamide 03 17.039546 5.304567e+10 88.071837 2.809453e+09 14186 P39120 CitZ iBAQ Diamide_03 3.895811 Diamide 03 533.536478 1.660948e+12 2757.675511 8.796864e+10 6599 Q01464 MinD iBAQ Control_01 -0.565776 Control 01 9.159222 3.760164e+11 624.300851 2.457695e+10 <pre><code>\n</code></pre>"},{"location":"abs_quant/","title":"Absolute Proteome Quantification","text":""},{"location":"abs_quant/#introduction","title":"Introduction","text":"<p>Absolute proteome quantification refers to the precise determination of the absolute concentrations of proteins within a biological sample. This approach contrasts with relative quantification methods, which measure changes in protein abundance between different conditions without providing exact concentration values. Absolute quantification is achieved through techniques such as mass spectrometry, often involving the use of standards of known concentration.</p>"},{"location":"abs_quant/#relevance-of-absolute-quantification","title":"Relevance of Absolute Quantification","text":"<p>Determining absolute amounts of proteins is crucial for several reasons:</p> <ul> <li> <p>Systems Biology Modeling: Accurate protein concentrations are essential for constructing quantitative models of cellular processes, enabling a deeper understanding of biological systems.</p> </li> <li> <p>Biomarker Validation: Determining exact protein levels aids in validating biomarkers for disease diagnosis and prognosis, leading to more reliable clinical applications.</p> </li> <li> <p>Comparative Studies: Absolute quantification allows for direct comparison of protein concentrations across different studies and laboratories, enhancing reproducibility and data integration.</p> </li> </ul>"},{"location":"abs_quant/#advantages-over-relative-quantification","title":"Advantages Over Relative Quantification","text":"<p>While relative quantification is valuable for identifying changes in protein expression between conditions, absolute quantification offers distinct advantages:</p> <ul> <li> <p>Precision: Provides exact protein concentrations, facilitating detailed biochemical analyses.</p> </li> <li> <p>Standardization: Enables the use of universal concentration units, improving data comparability across studies.</p> </li> <li> <p>Comprehensive Analysis: Allows for the assessment of proteins that may not exhibit significant relative changes but are critical at specific concentrations for cellular functions.</p> </li> </ul>"},{"location":"abs_quant/#relevant-scientific-literature","title":"Relevant Scientific Literature","text":"<p>For further reading on absolute proteome quantification and its methodologies, consider the following sources:</p> <ul> <li> <p>Mass Spectrometry-Based Proteomics Turns Quantitative</p> </li> <li> <p>Quantitative Mass Spectrometry in Proteomics: A Critical Review</p> </li> <li> <p>Methods and applications of absolute protein quantification in microbial systems</p> </li> <li> <p>Absolute Protein Quantification by Mass Spectrometry: Not as Simple as Advertised</p> </li> </ul>"},{"location":"data_preprocessing/","title":"\ud83e\uddfc Data Pre-processing","text":"<p>Data import and pre-processing are fundamental steps in proteomics analysis with Alpaca, ensuring that raw experimental data is transformed into a clean, standardized format for downstream analysis. In the context of <code>alpaca_proteomics</code>, these steps are critical and applicable for both relative and absolute quantification in quantitative proteomics.  </p> <p>Proper pre-processing removes contaminants, handles missing values, and normalizes datasets, minimizing technical variability and enhancing the accuracy of protein quantification. This ensures robust and reproducible results, enabling meaningful biological insights. The library streamlines these tasks, making it highly applicable for workflows involving large-scale proteomics data.</p>"},{"location":"data_preprocessing/#overview-of-the-workflow","title":"\ud83d\udd01 Overview of the Workflow","text":"<p>The pre-processing pipeline in <code>alpaca</code> consists of three main steps:</p> <ol> <li>Import raw data using <code>alpaca.eats()</code> </li> <li>Consult (Optional) an automated advisor via <code>alpaca.Consultant()</code> to choose optimal parameters</li> <li>Clean the dataset with <code>alpaca.spits()</code> </li> </ol>"},{"location":"data_preprocessing/#1-importing-data-with-alpacaeats","title":"\ud83d\udce5 1. Importing Data with <code>alpaca.eats()</code>","text":"<p>\ud83d\udcda Function Overview</p> <p><code>alpaca.eats()</code> ingests proteomics data files in various formats and returns a structured <code>pandas.DataFrame</code>.</p>"},{"location":"data_preprocessing/#alpacaeatsfile-inspecttrue","title":"<code>alpaca.eats(file, inspect=True)</code>","text":"<p>Loads proteomics data from a file in <code>.txt</code>, <code>.tsv</code>, <code>.csv</code>, or <code>.xlsx</code> format.</p> <p>Parameters:</p> <ul> <li> <p><code>file</code> (<code>str</code> or file-like):   Path to the data file or an open file object. Supported formats include:</p> <ul> <li><code>.txt</code> or <code>.tsv</code>: Tab-separated values  </li> <li><code>.csv</code>: Comma-separated values  </li> <li><code>.xlsx</code>: Excel spreadsheet</li> </ul> </li> <li> <p><code>inspect</code> (<code>bool</code>, default=<code>True</code>):   If <code>True</code>, the function tries to identify the column containing protein group IDs and the available intensity methods using <code>detective.alpacaHolmes</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p>If <code>inspect=True</code> and detection is successful:   Returns a tuple <code>(DataFrame, id_col, intensity_dict)</code></p> </li> <li> <p>If <code>inspect=True</code> but detection fails:   Returns the <code>DataFrame</code> with a warning message.</p> </li> <li> <p>If <code>inspect=False</code>:   Returns the <code>DataFrame</code> only.</p> </li> </ul> <p>Notes:</p> <ul> <li>If the file format is not recognized, the function prints a message and returns <code>None</code>.</li> </ul> <p>Example Usage:</p> <pre><code>from alpaca_proteomics import alpaca\n\nfile = \"results.csv\"\n\ndata = alpaca.eats(file)\n</code></pre>"},{"location":"data_preprocessing/#2-quantification-assistance-withalpacaconsultant","title":"\ud83e\udd16 2. Quantification assistance with<code>alpaca.Consultant()</code>","text":""},{"location":"data_preprocessing/#alpacaconsultantdf-st_proteins-it-added_samplesall-norm_optionsnone-relative-median-quantile-values_per_sample03","title":"<code>alpaca.Consultant(df, st_proteins, it, added_samples='all', norm_options=['None', 'Relative', 'Median', 'Quantile'], values_per_sample=0.3)</code>","text":"<p>Suggests the best normalization and intensity method for protein quantification based on regression performance with spiked-in standards.</p> <p>Parameters:</p> <ul> <li> <p><code>df</code> (<code>pandas.DataFrame</code>):   DataFrame containing the quantified protein data to be analyzed.</p> </li> <li> <p><code>st_proteins</code> (<code>pandas.DataFrame</code>):   DataFrame containing the spiked-in standards used for regression-based quantification.</p> </li> <li> <p><code>it</code> (<code>dict</code>):   Dictionary where keys are intensity methods (e.g., 'LFQ') and values are lists of corresponding sample names.</p> </li> <li> <p><code>added_samples</code> (<code>list</code> or <code>'all'</code>, default=<code>'all'</code>):   List of sample names to apply the analysis to. If <code>'all'</code>, applies to all samples.</p> </li> <li> <p><code>norm_options</code> (<code>list</code>, default=<code>['None', 'Relative', 'Median', 'Quantile']</code>):   List of normalization options to test during analysis.</p> </li> <li> <p><code>values_per_sample</code> (<code>float</code>, default=<code>0.3</code>):   Minimum proportion of valid values (non-missing) required per sample for analysis.</p> </li> </ul> <p>Returns:</p> <ul> <li><code>pandas.DataFrame</code>:   DataFrame with tested normalization and intensity methods, and their corresponding R\u00b2 scores.</li> </ul> <p>Notes:</p> <ul> <li>The function runs regression analysis for each combination of normalization and intensity method, evaluating the quality of fit using R\u00b2.</li> <li>Based on the highest R\u00b2 score, the function recommends the best combination of intensity method and normalization for protein quantification.</li> </ul>"},{"location":"data_preprocessing/#3-data-pre-processing-with-alpacaspits","title":"\ud83e\uddf9 3. Data pre-processing with <code>alpaca.spits()</code>","text":""},{"location":"data_preprocessing/#alpacaspitsdata-lfq_method-id_colauto-replicate_dictauto-intensity_dictauto-info_colsnone-contamination_colsidentified-by-site-contaminant-reverse-cleaningtrue-formattingauto-transformationnplog2-normalizationnone-valid_values07-imputation-imp_kwargs","title":"<code>alpaca.spits(data, lfq_method, id_col='auto', replicate_dict='auto', intensity_dict='auto', info_cols=None, contamination_cols=['identified by site', 'contaminant', 'Reverse'], cleaning=True, formatting='auto', transformation=np.log2, normalization=None, valid_values=0.7, imputation='', **imp_kwargs)</code>","text":"<p>Processes a proteomics DataFrame for quantitative analysis, performing tasks such as cleaning, transformation, imputation, normalization, and formatting for downstream analysis or visualization.</p> <p>Parameters:</p> <ul> <li> <p><code>data</code> (<code>pandas.DataFrame</code>):   Input DataFrame containing the raw intensity data.</p> </li> <li> <p><code>lfq_method</code> (<code>str</code>):   Column name or label-free quantification (LFQ) method used to extract intensities.</p> </li> <li> <p><code>id_col</code> (<code>str</code>, default=<code>'auto'</code>):   Column name containing unique protein identifiers. If <code>'auto'</code>, it is inferred using <code>detective.alpacaHolmes</code>.</p> </li> <li> <p><code>replicate_dict</code> (<code>dict</code> or <code>'auto'</code>, default=<code>'auto'</code>):   Dictionary mapping sample names to <code>Condition;Replicate</code> values. If <code>'auto'</code>, it is inferred using <code>detective.alpacaWatson</code>.</p> </li> <li> <p><code>intensity_dict</code> (<code>dict</code> or <code>'auto'</code>, default=<code>'auto'</code>):   Dictionary mapping LFQ methods to their corresponding columns. Inferred automatically if set to <code>'auto'</code>.</p> </li> <li> <p><code>info_cols</code> (<code>list</code>, optional):   Columns containing additional metadata to retain. If <code>None</code>, selected based on common patterns.</p> </li> <li> <p><code>contamination_cols</code> (<code>list</code>, default=<code>['identified by site', 'contaminant', 'Reverse']</code>):   Columns used to identify and remove contaminants or reverse hits.</p> </li> <li> <p><code>cleaning</code> (<code>bool</code>, default=<code>True</code>):   Whether to filter out contaminants and reverse hits.</p> </li> <li> <p><code>formatting</code> (<code>str</code> or <code>bool</code>, default=<code>'auto'</code>):   Controls output format. If <code>True</code>, returns long-format data suitable for downstream processing.   If <code>'auto'</code>, formatting is inferred.</p> </li> <li> <p><code>transformation</code> (<code>callable</code>, default=<code>np.log2</code>):   Function used to transform intensity values (e.g., log transformation).</p> </li> <li> <p><code>normalization</code> (<code>str</code>, default=<code>None</code>):   Normalization method. Accepted values: <code>'None'</code>, <code>'Relative'</code>, <code>'Median'</code>, <code>'Quantile'</code>.</p> </li> <li> <p><code>valid_values</code> (<code>float</code>, default=<code>0.7</code>):   Minimum proportion of valid values (non-missing) required to retain a row per condition.</p> </li> <li> <p><code>imputation</code> (<code>str</code>, default=<code>''</code>):   Imputation method for missing values. Available options:   <code>'None'</code>, <code>'LOD'</code>, <code>'ND'</code>, <code>'kNN'</code>, <code>'LLS'</code>, <code>'SVD'</code>.   If empty, no imputation is applied.</p> </li> <li> <p><code>**imp_kwargs</code> (<code>dict</code>):   Additional keyword arguments passed to the imputation function, if specified.</p> </li> </ul> <p>Returns:</p> <ul> <li><code>pandas.DataFrame</code>:   A processed DataFrame, either in long format (for analysis and plotting) or wide format (for inspection), depending on the <code>formatting</code> parameter.</li> </ul> <p>Notes:</p> <ul> <li>Requires an intensity column and a way to define biological replicates.</li> <li>If any key components (<code>id_col</code>, <code>replicate_dict</code>, or <code>intensity_dict</code>) are set to <code>'auto'</code>, the function attempts to detect them automatically.</li> <li>Designed to integrate with the <code>alpaca</code> pipeline and its internal modules like <code>detective</code>, <code>tools</code>, <code>Imputation</code>, and <code>Normalization</code>.</li> </ul>"},{"location":"enrichment/","title":"Enrichment","text":""},{"location":"enrichment/#alpacagathersdf-enrichment_standards-preparation-lfq_methodibaq-plotfalse-save_plotfalse","title":"<code>alpaca.gathers(df, enrichment_standards, preparation, lfq_method='iBAQ', plot=False, save_plot=False)</code>","text":"<p>Calculates enrichment factors for protein standards spiked into samples and optionally plots the results.</p> <p>Parameters:</p> <ul> <li> <p><code>df</code> (<code>pandas.DataFrame</code>):   DataFrame containing the quantified protein data (e.g., with iBAQ or LFQ values).</p> </li> <li> <p><code>enrichment_standards</code> (<code>pandas.DataFrame</code> or file-like object):   DataFrame or file containing the standard information for calculating enrichment.</p> </li> <li> <p><code>preparation</code> (<code>pandas.DataFrame</code>):   DataFrame containing information about the experimental preparation (e.g., conditions).</p> </li> <li> <p><code>lfq_method</code> (<code>str</code>, optional, default=<code>'iBAQ'</code>):   Label-free quantification method used in the analysis (e.g., 'iBAQ', 'LFQ').</p> </li> <li> <p><code>plot</code> (<code>bool</code>, optional, default=<code>False</code>):   Whether to plot the enrichment factors.</p> </li> <li> <p><code>save_plot</code> (<code>bool</code>, optional, default=<code>False</code>):   Whether to save the plot as a file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p><code>e_test</code> (<code>pandas.DataFrame</code>):   DataFrame containing calculated enrichment values for each sample.</p> </li> <li> <p><code>preparation</code> (<code>pandas.DataFrame</code>):   Updated preparation DataFrame with enrichment factors added.</p> </li> </ul> <p>Notes:</p> <ul> <li>The function calculates the enrichment factors by comparing the protein levels in the experimental samples to the spiked-in standards.</li> <li>It groups the data by experimental conditions and replicates to calculate median enrichment values.</li> <li>The function also optionally generates and saves a plot of the enrichment values.</li> </ul>"},{"location":"getting_started/","title":"Getting Started","text":"<p>Welcome to the documentation for alpaca_proteomics \ud83c\udf89</p> <p>This guide will help you install the package and set up your environment.</p>"},{"location":"getting_started/#1-install-the-package","title":"1. Install the package","text":"<pre><code>pip install alpaca_proteomics\n</code></pre>"},{"location":"getting_started/#2-import-the-package","title":"2. Import the package","text":"<pre><code>from alpaca_proteomics import alpaca \n</code></pre>"},{"location":"getting_started/#requirements","title":"\ud83e\udde9 Requirements","text":"<p>Before installing, make sure you have the following:</p> <ul> <li>Python 3.8+</li> <li>pip</li> <li>(Optional) virtualenv</li> </ul> <p>You can check your Python version with:</p> <pre><code>bash\npython --version\n\ngit clone https://github.com/borfebor/alpaca_proteomics.git\ncd alpaca_proteomics\npip install -e .\n\npython -c \"import alpaca_proteomics; print(alpaca_proteomics.__version__)\"\n</code></pre> <p>The following packages are required for the correct execution of alpaca_proteomics:</p> <ul> <li>matplotlib</li> <li>numpy</li> <li>pandas</li> <li>scikit-learn</li> <li>scipy</li> <li>seaborn</li> <li>thefuzz</li> <li>XlsxWriter</li> </ul>"},{"location":"integration/","title":"Data integration","text":""},{"location":"integration/#alpacawooldf-preparation","title":"<code>alpaca.wool(df, preparation)</code>","text":"<p>Integrates experimental preparation with the measured molar amounts. Applies enrichment factor corrections to a dataframe, converts amounts to molecules using Avogadro's number, and computes sample-specific and cell-specific molecule concentrations.</p> <p>Parameters:</p> <ul> <li> <p><code>df</code> (<code>pandas.DataFrame</code>):   DataFrame containing the quantified protein data (e.g., fmol values).</p> </li> <li> <p><code>preparation</code> (<code>pandas.DataFrame</code>):   DataFrame containing experimental setup and enrichment information (e.g., Enrichment factors, sample volumes).</p> </li> </ul> <p>Returns:</p> <ul> <li><code>df</code> (<code>pandas.DataFrame</code>):   Updated DataFrame with corrected fmol values and molecule counts.</li> </ul> <p>Notes:</p> <ul> <li>The function applies enrichment factor corrections based on whether the sample mode is enriched (for increased fraction) or concentrated (for decreased fraction).</li> <li>The molecule counts are calculated using Avogadro's number for conversion from fmol to molecules.</li> <li>The function can also compute sample-specific and cell-specific concentrations based on the experimental setup provided in the <code>preparation</code> DataFrame.</li> </ul>"},{"location":"quantification/","title":"\ud83d\udd22 Quantification","text":"<p>The quantification module of the ALPACA (Absolute Protein Quantification) proteomics pipeline is designed to facilitate the analysis of absolute protein quantification data. This Python-based tool streamlines the processing of mass spectrometry data, enabling researchers to accurately determine protein abundances in complex biological samples. By integrating with various proteomics data formats and employing robust statistical methods, the module ensures precise quantification, thereby enhancing the reliability of downstream analyses.</p> <p>This module is especially valuable for researchers working with large-scale proteomics datasets, as it simplifies the steps necessary to generate quantitative data that can be used for a wide range of biological insights.</p>"},{"location":"quantification/#function-alpacacensus","title":"\ud83e\uddee Function: <code>alpaca.census()</code>","text":"<p>The primary function in the quantification module, <code>alpaca.census()</code>, is responsible for performing the absolute quantification of protein abundances using various statistical methods.</p>"},{"location":"quantification/#alpacacensusdf-standards-concentration05-in_sample60-lfq_colibaq-ratio1-total_protein1-filter_colreplicate-added_samplesnone-valid_values0-plottrue-savefalse","title":"<code>alpaca.census(df, standards, concentration=0.5, in_sample=6.0, lfq_col='iBAQ', ratio=1, total_protein=1, filter_col='Replicate', added_samples=None, valid_values=0, plot=True, save=False)</code>","text":"<p>Performs protein quantification using regression between quantified protein intensities and dynamic standards (e.g., UPS2).</p> <p>Parameters:</p> <ul> <li> <p><code>df</code> (<code>pandas.DataFrame</code>):   DataFrame containing clean data for quantified proteins.</p> </li> <li> <p><code>standards</code> (<code>str</code> or file-like object):   Path to a file containing UPS2 dynamic standards information or the standards file itself (e.g., .csv, .txt, .xlsx).</p> </li> <li> <p><code>concentration</code> (<code>float</code>, optional, default=<code>0.5</code>):   Stock concentration of the standards in mg/mL.</p> </li> <li> <p><code>in_sample</code> (<code>float</code>, optional, default=<code>6.0</code>):   Volume (in microliters) of standards added to each sample.</p> </li> <li> <p><code>lfq_col</code> (<code>str</code>, optional, default=<code>'iBAQ'</code>):   Column name in <code>df</code> representing the intensity values.</p> </li> <li> <p><code>ratio</code> (<code>float</code>, optional, default=<code>1</code>):   A multiplier for adjusting the calculated concentration of standard proteins to the sample amount.</p> </li> <li> <p><code>total_protein</code> (<code>float</code>, optional, default=<code>1</code>):   Total protein concentration in the sample.</p> </li> <li> <p><code>filter_col</code> (<code>str</code>, optional, default=<code>'Replicate'</code>):   Column name used to filter data for specific replicates or conditions.</p> </li> <li> <p><code>added_samples</code> (<code>list</code>, optional, default=<code>None</code>):   List of samples or conditions where standards were added. If <code>None</code>, assumes standards were added to all samples.</p> </li> <li> <p><code>valid_values</code> (<code>int</code>, optional, default=<code>2</code>):   Minimum number of valid (non-missing) values required for regression.</p> </li> <li> <p><code>plot</code> (<code>bool</code>, optional, default=<code>True</code>):   Whether to generate and display regression plots.</p> </li> <li> <p><code>save</code> (<code>bool</code>, optional, default=<code>False</code>):   Whether to save the regression plots.</p> </li> </ul> <p>Returns:</p> <ul> <li> <p><code>df</code> (<code>pandas.DataFrame</code>):   DataFrame with quantified proteins, adjusted for concentration.</p> </li> <li> <p><code>ups_red</code> (<code>pandas.DataFrame</code>):   DataFrame containing measured standards in the sample.</p> </li> <li> <p><code>coef</code> (<code>float</code>):   Regression slope used for quantification.</p> </li> <li> <p><code>inter</code> (<code>float</code>):   Regression intercept used for quantification.</p> </li> <li> <p><code>R2</code> (<code>float</code>):   R-squared value representing the goodness-of-fit for the regression.</p> </li> </ul> <p>Notes:</p> <ul> <li>The function performs regression analysis between protein intensities in <code>df</code> and spiked-in dynamic standards (e.g., UPS2) to quantify proteins.</li> <li>It provides an option to visualize and save regression plots.</li> <li>A low R\u00b2 value (less than 0.8) indicates a poor fit for the regression and should be carefully reviewed.</li> </ul>"},{"location":"quantification/#signature","title":"\ud83e\uddfe Signature","text":"<p><code>`python alpaca.census(data, method=\"sum\", target_protein=\"total_protein\", normalize=False)</code></p>"}]}